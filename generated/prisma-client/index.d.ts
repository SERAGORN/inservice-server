// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  boughHistory: (where?: BoughHistoryWhereInput) => Promise<boolean>;
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  service: (where?: ServiceWhereInput) => Promise<boolean>;
  soldHistory: (where?: SoldHistoryWhereInput) => Promise<boolean>;
  tender: (where?: TenderWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  boughHistory: (
    where: BoughHistoryWhereUniqueInput
  ) => BoughHistoryNullablePromise;
  boughHistories: (args?: {
    where?: BoughHistoryWhereInput;
    orderBy?: BoughHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BoughHistory>;
  boughHistoriesConnection: (args?: {
    where?: BoughHistoryWhereInput;
    orderBy?: BoughHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BoughHistoryConnectionPromise;
  category: (where: CategoryWhereUniqueInput) => CategoryNullablePromise;
  categories: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Category>;
  categoriesConnection: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CategoryConnectionPromise;
  comment: (where: CommentWhereUniqueInput) => CommentNullablePromise;
  comments: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Comment>;
  commentsConnection: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentConnectionPromise;
  service: (where: ServiceWhereUniqueInput) => ServiceNullablePromise;
  services: (args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Service>;
  servicesConnection: (args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ServiceConnectionPromise;
  soldHistory: (
    where: SoldHistoryWhereUniqueInput
  ) => SoldHistoryNullablePromise;
  soldHistories: (args?: {
    where?: SoldHistoryWhereInput;
    orderBy?: SoldHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SoldHistory>;
  soldHistoriesConnection: (args?: {
    where?: SoldHistoryWhereInput;
    orderBy?: SoldHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SoldHistoryConnectionPromise;
  tender: (where: TenderWhereUniqueInput) => TenderNullablePromise;
  tenders: (args?: {
    where?: TenderWhereInput;
    orderBy?: TenderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tender>;
  tendersConnection: (args?: {
    where?: TenderWhereInput;
    orderBy?: TenderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TenderConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBoughHistory: (data: BoughHistoryCreateInput) => BoughHistoryPromise;
  updateBoughHistory: (args: {
    data: BoughHistoryUpdateInput;
    where: BoughHistoryWhereUniqueInput;
  }) => BoughHistoryPromise;
  upsertBoughHistory: (args: {
    where: BoughHistoryWhereUniqueInput;
    create: BoughHistoryCreateInput;
    update: BoughHistoryUpdateInput;
  }) => BoughHistoryPromise;
  deleteBoughHistory: (
    where: BoughHistoryWhereUniqueInput
  ) => BoughHistoryPromise;
  deleteManyBoughHistories: (
    where?: BoughHistoryWhereInput
  ) => BatchPayloadPromise;
  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (args: {
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
  }) => CategoryPromise;
  updateManyCategories: (args: {
    data: CategoryUpdateManyMutationInput;
    where?: CategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
  }) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (args: {
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
  }) => CommentPromise;
  updateManyComments: (args: {
    data: CommentUpdateManyMutationInput;
    where?: CommentWhereInput;
  }) => BatchPayloadPromise;
  upsertComment: (args: {
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
  }) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createService: (data: ServiceCreateInput) => ServicePromise;
  updateService: (args: {
    data: ServiceUpdateInput;
    where: ServiceWhereUniqueInput;
  }) => ServicePromise;
  updateManyServices: (args: {
    data: ServiceUpdateManyMutationInput;
    where?: ServiceWhereInput;
  }) => BatchPayloadPromise;
  upsertService: (args: {
    where: ServiceWhereUniqueInput;
    create: ServiceCreateInput;
    update: ServiceUpdateInput;
  }) => ServicePromise;
  deleteService: (where: ServiceWhereUniqueInput) => ServicePromise;
  deleteManyServices: (where?: ServiceWhereInput) => BatchPayloadPromise;
  createSoldHistory: (data: SoldHistoryCreateInput) => SoldHistoryPromise;
  updateSoldHistory: (args: {
    data: SoldHistoryUpdateInput;
    where: SoldHistoryWhereUniqueInput;
  }) => SoldHistoryPromise;
  upsertSoldHistory: (args: {
    where: SoldHistoryWhereUniqueInput;
    create: SoldHistoryCreateInput;
    update: SoldHistoryUpdateInput;
  }) => SoldHistoryPromise;
  deleteSoldHistory: (where: SoldHistoryWhereUniqueInput) => SoldHistoryPromise;
  deleteManySoldHistories: (
    where?: SoldHistoryWhereInput
  ) => BatchPayloadPromise;
  createTender: (data: TenderCreateInput) => TenderPromise;
  updateTender: (args: {
    data: TenderUpdateInput;
    where: TenderWhereUniqueInput;
  }) => TenderPromise;
  updateManyTenders: (args: {
    data: TenderUpdateManyMutationInput;
    where?: TenderWhereInput;
  }) => BatchPayloadPromise;
  upsertTender: (args: {
    where: TenderWhereUniqueInput;
    create: TenderCreateInput;
    update: TenderUpdateInput;
  }) => TenderPromise;
  deleteTender: (where: TenderWhereUniqueInput) => TenderPromise;
  deleteManyTenders: (where?: TenderWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  boughHistory: (
    where?: BoughHistorySubscriptionWhereInput
  ) => BoughHistorySubscriptionPayloadSubscription;
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  service: (
    where?: ServiceSubscriptionWhereInput
  ) => ServiceSubscriptionPayloadSubscription;
  soldHistory: (
    where?: SoldHistorySubscriptionWhereInput
  ) => SoldHistorySubscriptionPayloadSubscription;
  tender: (
    where?: TenderSubscriptionWhereInput
  ) => TenderSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type TenderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "price_ASC"
  | "price_DESC"
  | "comment_ASC"
  | "comment_DESC"
  | "accept_ASC"
  | "accept_DESC";

export type ServiceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "address_ASC"
  | "address_DESC"
  | "price_ASC"
  | "price_DESC"
  | "done_ASC"
  | "done_DESC"
  | "timeToDo_ASC"
  | "timeToDo_DESC"
  | "created_ASC"
  | "created_DESC";

export type SoldHistoryOrderByInput = "id_ASC" | "id_DESC";

export type BoughHistoryOrderByInput = "id_ASC" | "id_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "message_ASC"
  | "message_DESC";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "phone_ASC"
  | "phone_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type BoughHistoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TenderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  service?: Maybe<ServiceWhereInput>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  user?: Maybe<UserWhereInput>;
  comment?: Maybe<String>;
  comment_not?: Maybe<String>;
  comment_in?: Maybe<String[] | String>;
  comment_not_in?: Maybe<String[] | String>;
  comment_lt?: Maybe<String>;
  comment_lte?: Maybe<String>;
  comment_gt?: Maybe<String>;
  comment_gte?: Maybe<String>;
  comment_contains?: Maybe<String>;
  comment_not_contains?: Maybe<String>;
  comment_starts_with?: Maybe<String>;
  comment_not_starts_with?: Maybe<String>;
  comment_ends_with?: Maybe<String>;
  comment_not_ends_with?: Maybe<String>;
  accept?: Maybe<Boolean>;
  accept_not?: Maybe<Boolean>;
  AND?: Maybe<TenderWhereInput[] | TenderWhereInput>;
  OR?: Maybe<TenderWhereInput[] | TenderWhereInput>;
  NOT?: Maybe<TenderWhereInput[] | TenderWhereInput>;
}

export interface ServiceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  done?: Maybe<Boolean>;
  done_not?: Maybe<Boolean>;
  timeToDo?: Maybe<String>;
  timeToDo_not?: Maybe<String>;
  timeToDo_in?: Maybe<String[] | String>;
  timeToDo_not_in?: Maybe<String[] | String>;
  timeToDo_lt?: Maybe<String>;
  timeToDo_lte?: Maybe<String>;
  timeToDo_gt?: Maybe<String>;
  timeToDo_gte?: Maybe<String>;
  timeToDo_contains?: Maybe<String>;
  timeToDo_not_contains?: Maybe<String>;
  timeToDo_starts_with?: Maybe<String>;
  timeToDo_not_starts_with?: Maybe<String>;
  timeToDo_ends_with?: Maybe<String>;
  timeToDo_not_ends_with?: Maybe<String>;
  created?: Maybe<String>;
  created_not?: Maybe<String>;
  created_in?: Maybe<String[] | String>;
  created_not_in?: Maybe<String[] | String>;
  created_lt?: Maybe<String>;
  created_lte?: Maybe<String>;
  created_gt?: Maybe<String>;
  created_gte?: Maybe<String>;
  created_contains?: Maybe<String>;
  created_not_contains?: Maybe<String>;
  created_starts_with?: Maybe<String>;
  created_not_starts_with?: Maybe<String>;
  created_ends_with?: Maybe<String>;
  created_not_ends_with?: Maybe<String>;
  tenders_every?: Maybe<TenderWhereInput>;
  tenders_some?: Maybe<TenderWhereInput>;
  tenders_none?: Maybe<TenderWhereInput>;
  user?: Maybe<UserWhereInput>;
  category?: Maybe<CategoryWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  AND?: Maybe<ServiceWhereInput[] | ServiceWhereInput>;
  OR?: Maybe<ServiceWhereInput[] | ServiceWhereInput>;
  NOT?: Maybe<ServiceWhereInput[] | ServiceWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  services_every?: Maybe<ServiceWhereInput>;
  services_some?: Maybe<ServiceWhereInput>;
  services_none?: Maybe<ServiceWhereInput>;
  soldHistory_every?: Maybe<SoldHistoryWhereInput>;
  soldHistory_some?: Maybe<SoldHistoryWhereInput>;
  soldHistory_none?: Maybe<SoldHistoryWhereInput>;
  boughHistory_every?: Maybe<BoughHistoryWhereInput>;
  boughHistory_some?: Maybe<BoughHistoryWhereInput>;
  boughHistory_none?: Maybe<BoughHistoryWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface SoldHistoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  service?: Maybe<ServiceWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<SoldHistoryWhereInput[] | SoldHistoryWhereInput>;
  OR?: Maybe<SoldHistoryWhereInput[] | SoldHistoryWhereInput>;
  NOT?: Maybe<SoldHistoryWhereInput[] | SoldHistoryWhereInput>;
}

export interface BoughHistoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  service?: Maybe<ServiceWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<BoughHistoryWhereInput[] | BoughHistoryWhereInput>;
  OR?: Maybe<BoughHistoryWhereInput[] | BoughHistoryWhereInput>;
  NOT?: Maybe<BoughHistoryWhereInput[] | BoughHistoryWhereInput>;
}

export interface CategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  services_every?: Maybe<ServiceWhereInput>;
  services_some?: Maybe<ServiceWhereInput>;
  services_none?: Maybe<ServiceWhereInput>;
  AND?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  OR?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  NOT?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
}

export interface CommentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  service?: Maybe<ServiceWhereInput>;
  AND?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  OR?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  NOT?: Maybe<CommentWhereInput[] | CommentWhereInput>;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type CommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ServiceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SoldHistoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TenderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface BoughHistoryCreateInput {
  id?: Maybe<ID_Input>;
  service?: Maybe<ServiceCreateOneInput>;
  user?: Maybe<UserCreateOneWithoutBoughHistoryInput>;
}

export interface ServiceCreateOneInput {
  create?: Maybe<ServiceCreateInput>;
  connect?: Maybe<ServiceWhereUniqueInput>;
}

export interface ServiceCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  address: String;
  price: Int;
  done?: Maybe<Boolean>;
  timeToDo: String;
  created: String;
  tenders?: Maybe<TenderCreateManyWithoutServiceInput>;
  user?: Maybe<UserCreateOneWithoutServicesInput>;
  category?: Maybe<CategoryCreateOneWithoutServicesInput>;
  comments?: Maybe<CommentCreateManyWithoutServiceInput>;
}

export interface TenderCreateManyWithoutServiceInput {
  create?: Maybe<
    TenderCreateWithoutServiceInput[] | TenderCreateWithoutServiceInput
  >;
  connect?: Maybe<TenderWhereUniqueInput[] | TenderWhereUniqueInput>;
}

export interface TenderCreateWithoutServiceInput {
  id?: Maybe<ID_Input>;
  price: Int;
  user?: Maybe<UserCreateOneInput>;
  comment: String;
  accept?: Maybe<Boolean>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email?: Maybe<String>;
  phone: String;
  services?: Maybe<ServiceCreateManyWithoutUserInput>;
  soldHistory?: Maybe<SoldHistoryCreateManyWithoutUserInput>;
  boughHistory?: Maybe<BoughHistoryCreateManyWithoutUserInput>;
}

export interface ServiceCreateManyWithoutUserInput {
  create?: Maybe<
    ServiceCreateWithoutUserInput[] | ServiceCreateWithoutUserInput
  >;
  connect?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
}

export interface ServiceCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  address: String;
  price: Int;
  done?: Maybe<Boolean>;
  timeToDo: String;
  created: String;
  tenders?: Maybe<TenderCreateManyWithoutServiceInput>;
  category?: Maybe<CategoryCreateOneWithoutServicesInput>;
  comments?: Maybe<CommentCreateManyWithoutServiceInput>;
}

export interface CategoryCreateOneWithoutServicesInput {
  create?: Maybe<CategoryCreateWithoutServicesInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface CategoryCreateWithoutServicesInput {
  id?: Maybe<ID_Input>;
  title: String;
}

export interface CommentCreateManyWithoutServiceInput {
  create?: Maybe<
    CommentCreateWithoutServiceInput[] | CommentCreateWithoutServiceInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutServiceInput {
  id?: Maybe<ID_Input>;
  message: String;
  user?: Maybe<UserCreateOneInput>;
}

export interface SoldHistoryCreateManyWithoutUserInput {
  create?: Maybe<
    SoldHistoryCreateWithoutUserInput[] | SoldHistoryCreateWithoutUserInput
  >;
  connect?: Maybe<SoldHistoryWhereUniqueInput[] | SoldHistoryWhereUniqueInput>;
}

export interface SoldHistoryCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  service?: Maybe<ServiceCreateOneInput>;
}

export interface BoughHistoryCreateManyWithoutUserInput {
  create?: Maybe<
    BoughHistoryCreateWithoutUserInput[] | BoughHistoryCreateWithoutUserInput
  >;
  connect?: Maybe<
    BoughHistoryWhereUniqueInput[] | BoughHistoryWhereUniqueInput
  >;
}

export interface BoughHistoryCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  service?: Maybe<ServiceCreateOneInput>;
}

export interface UserCreateOneWithoutServicesInput {
  create?: Maybe<UserCreateWithoutServicesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutServicesInput {
  id?: Maybe<ID_Input>;
  name: String;
  email?: Maybe<String>;
  phone: String;
  soldHistory?: Maybe<SoldHistoryCreateManyWithoutUserInput>;
  boughHistory?: Maybe<BoughHistoryCreateManyWithoutUserInput>;
}

export interface UserCreateOneWithoutBoughHistoryInput {
  create?: Maybe<UserCreateWithoutBoughHistoryInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutBoughHistoryInput {
  id?: Maybe<ID_Input>;
  name: String;
  email?: Maybe<String>;
  phone: String;
  services?: Maybe<ServiceCreateManyWithoutUserInput>;
  soldHistory?: Maybe<SoldHistoryCreateManyWithoutUserInput>;
}

export interface BoughHistoryUpdateInput {
  service?: Maybe<ServiceUpdateOneInput>;
  user?: Maybe<UserUpdateOneWithoutBoughHistoryInput>;
}

export interface ServiceUpdateOneInput {
  create?: Maybe<ServiceCreateInput>;
  update?: Maybe<ServiceUpdateDataInput>;
  upsert?: Maybe<ServiceUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ServiceWhereUniqueInput>;
}

export interface ServiceUpdateDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  address?: Maybe<String>;
  price?: Maybe<Int>;
  done?: Maybe<Boolean>;
  timeToDo?: Maybe<String>;
  created?: Maybe<String>;
  tenders?: Maybe<TenderUpdateManyWithoutServiceInput>;
  user?: Maybe<UserUpdateOneWithoutServicesInput>;
  category?: Maybe<CategoryUpdateOneWithoutServicesInput>;
  comments?: Maybe<CommentUpdateManyWithoutServiceInput>;
}

export interface TenderUpdateManyWithoutServiceInput {
  create?: Maybe<
    TenderCreateWithoutServiceInput[] | TenderCreateWithoutServiceInput
  >;
  delete?: Maybe<TenderWhereUniqueInput[] | TenderWhereUniqueInput>;
  connect?: Maybe<TenderWhereUniqueInput[] | TenderWhereUniqueInput>;
  set?: Maybe<TenderWhereUniqueInput[] | TenderWhereUniqueInput>;
  disconnect?: Maybe<TenderWhereUniqueInput[] | TenderWhereUniqueInput>;
  update?: Maybe<
    | TenderUpdateWithWhereUniqueWithoutServiceInput[]
    | TenderUpdateWithWhereUniqueWithoutServiceInput
  >;
  upsert?: Maybe<
    | TenderUpsertWithWhereUniqueWithoutServiceInput[]
    | TenderUpsertWithWhereUniqueWithoutServiceInput
  >;
  deleteMany?: Maybe<TenderScalarWhereInput[] | TenderScalarWhereInput>;
  updateMany?: Maybe<
    | TenderUpdateManyWithWhereNestedInput[]
    | TenderUpdateManyWithWhereNestedInput
  >;
}

export interface TenderUpdateWithWhereUniqueWithoutServiceInput {
  where: TenderWhereUniqueInput;
  data: TenderUpdateWithoutServiceDataInput;
}

export interface TenderUpdateWithoutServiceDataInput {
  price?: Maybe<Int>;
  user?: Maybe<UserUpdateOneInput>;
  comment?: Maybe<String>;
  accept?: Maybe<Boolean>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  services?: Maybe<ServiceUpdateManyWithoutUserInput>;
  soldHistory?: Maybe<SoldHistoryUpdateManyWithoutUserInput>;
  boughHistory?: Maybe<BoughHistoryUpdateManyWithoutUserInput>;
}

export interface ServiceUpdateManyWithoutUserInput {
  create?: Maybe<
    ServiceCreateWithoutUserInput[] | ServiceCreateWithoutUserInput
  >;
  delete?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  connect?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  set?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  disconnect?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  update?: Maybe<
    | ServiceUpdateWithWhereUniqueWithoutUserInput[]
    | ServiceUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | ServiceUpsertWithWhereUniqueWithoutUserInput[]
    | ServiceUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<ServiceScalarWhereInput[] | ServiceScalarWhereInput>;
  updateMany?: Maybe<
    | ServiceUpdateManyWithWhereNestedInput[]
    | ServiceUpdateManyWithWhereNestedInput
  >;
}

export interface ServiceUpdateWithWhereUniqueWithoutUserInput {
  where: ServiceWhereUniqueInput;
  data: ServiceUpdateWithoutUserDataInput;
}

export interface ServiceUpdateWithoutUserDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  address?: Maybe<String>;
  price?: Maybe<Int>;
  done?: Maybe<Boolean>;
  timeToDo?: Maybe<String>;
  created?: Maybe<String>;
  tenders?: Maybe<TenderUpdateManyWithoutServiceInput>;
  category?: Maybe<CategoryUpdateOneWithoutServicesInput>;
  comments?: Maybe<CommentUpdateManyWithoutServiceInput>;
}

export interface CategoryUpdateOneWithoutServicesInput {
  create?: Maybe<CategoryCreateWithoutServicesInput>;
  update?: Maybe<CategoryUpdateWithoutServicesDataInput>;
  upsert?: Maybe<CategoryUpsertWithoutServicesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface CategoryUpdateWithoutServicesDataInput {
  title?: Maybe<String>;
}

export interface CategoryUpsertWithoutServicesInput {
  update: CategoryUpdateWithoutServicesDataInput;
  create: CategoryCreateWithoutServicesInput;
}

export interface CommentUpdateManyWithoutServiceInput {
  create?: Maybe<
    CommentCreateWithoutServiceInput[] | CommentCreateWithoutServiceInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutServiceInput[]
    | CommentUpdateWithWhereUniqueWithoutServiceInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutServiceInput[]
    | CommentUpsertWithWhereUniqueWithoutServiceInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueWithoutServiceInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutServiceDataInput;
}

export interface CommentUpdateWithoutServiceDataInput {
  message?: Maybe<String>;
  user?: Maybe<UserUpdateOneInput>;
}

export interface CommentUpsertWithWhereUniqueWithoutServiceInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutServiceDataInput;
  create: CommentCreateWithoutServiceInput;
}

export interface CommentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  AND?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  OR?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  NOT?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface CommentUpdateManyDataInput {
  message?: Maybe<String>;
}

export interface ServiceUpsertWithWhereUniqueWithoutUserInput {
  where: ServiceWhereUniqueInput;
  update: ServiceUpdateWithoutUserDataInput;
  create: ServiceCreateWithoutUserInput;
}

export interface ServiceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  done?: Maybe<Boolean>;
  done_not?: Maybe<Boolean>;
  timeToDo?: Maybe<String>;
  timeToDo_not?: Maybe<String>;
  timeToDo_in?: Maybe<String[] | String>;
  timeToDo_not_in?: Maybe<String[] | String>;
  timeToDo_lt?: Maybe<String>;
  timeToDo_lte?: Maybe<String>;
  timeToDo_gt?: Maybe<String>;
  timeToDo_gte?: Maybe<String>;
  timeToDo_contains?: Maybe<String>;
  timeToDo_not_contains?: Maybe<String>;
  timeToDo_starts_with?: Maybe<String>;
  timeToDo_not_starts_with?: Maybe<String>;
  timeToDo_ends_with?: Maybe<String>;
  timeToDo_not_ends_with?: Maybe<String>;
  created?: Maybe<String>;
  created_not?: Maybe<String>;
  created_in?: Maybe<String[] | String>;
  created_not_in?: Maybe<String[] | String>;
  created_lt?: Maybe<String>;
  created_lte?: Maybe<String>;
  created_gt?: Maybe<String>;
  created_gte?: Maybe<String>;
  created_contains?: Maybe<String>;
  created_not_contains?: Maybe<String>;
  created_starts_with?: Maybe<String>;
  created_not_starts_with?: Maybe<String>;
  created_ends_with?: Maybe<String>;
  created_not_ends_with?: Maybe<String>;
  AND?: Maybe<ServiceScalarWhereInput[] | ServiceScalarWhereInput>;
  OR?: Maybe<ServiceScalarWhereInput[] | ServiceScalarWhereInput>;
  NOT?: Maybe<ServiceScalarWhereInput[] | ServiceScalarWhereInput>;
}

export interface ServiceUpdateManyWithWhereNestedInput {
  where: ServiceScalarWhereInput;
  data: ServiceUpdateManyDataInput;
}

export interface ServiceUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  address?: Maybe<String>;
  price?: Maybe<Int>;
  done?: Maybe<Boolean>;
  timeToDo?: Maybe<String>;
  created?: Maybe<String>;
}

export interface SoldHistoryUpdateManyWithoutUserInput {
  create?: Maybe<
    SoldHistoryCreateWithoutUserInput[] | SoldHistoryCreateWithoutUserInput
  >;
  delete?: Maybe<SoldHistoryWhereUniqueInput[] | SoldHistoryWhereUniqueInput>;
  connect?: Maybe<SoldHistoryWhereUniqueInput[] | SoldHistoryWhereUniqueInput>;
  set?: Maybe<SoldHistoryWhereUniqueInput[] | SoldHistoryWhereUniqueInput>;
  disconnect?: Maybe<
    SoldHistoryWhereUniqueInput[] | SoldHistoryWhereUniqueInput
  >;
  update?: Maybe<
    | SoldHistoryUpdateWithWhereUniqueWithoutUserInput[]
    | SoldHistoryUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | SoldHistoryUpsertWithWhereUniqueWithoutUserInput[]
    | SoldHistoryUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    SoldHistoryScalarWhereInput[] | SoldHistoryScalarWhereInput
  >;
}

export interface SoldHistoryUpdateWithWhereUniqueWithoutUserInput {
  where: SoldHistoryWhereUniqueInput;
  data: SoldHistoryUpdateWithoutUserDataInput;
}

export interface SoldHistoryUpdateWithoutUserDataInput {
  service?: Maybe<ServiceUpdateOneInput>;
}

export interface SoldHistoryUpsertWithWhereUniqueWithoutUserInput {
  where: SoldHistoryWhereUniqueInput;
  update: SoldHistoryUpdateWithoutUserDataInput;
  create: SoldHistoryCreateWithoutUserInput;
}

export interface SoldHistoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<SoldHistoryScalarWhereInput[] | SoldHistoryScalarWhereInput>;
  OR?: Maybe<SoldHistoryScalarWhereInput[] | SoldHistoryScalarWhereInput>;
  NOT?: Maybe<SoldHistoryScalarWhereInput[] | SoldHistoryScalarWhereInput>;
}

export interface BoughHistoryUpdateManyWithoutUserInput {
  create?: Maybe<
    BoughHistoryCreateWithoutUserInput[] | BoughHistoryCreateWithoutUserInput
  >;
  delete?: Maybe<BoughHistoryWhereUniqueInput[] | BoughHistoryWhereUniqueInput>;
  connect?: Maybe<
    BoughHistoryWhereUniqueInput[] | BoughHistoryWhereUniqueInput
  >;
  set?: Maybe<BoughHistoryWhereUniqueInput[] | BoughHistoryWhereUniqueInput>;
  disconnect?: Maybe<
    BoughHistoryWhereUniqueInput[] | BoughHistoryWhereUniqueInput
  >;
  update?: Maybe<
    | BoughHistoryUpdateWithWhereUniqueWithoutUserInput[]
    | BoughHistoryUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | BoughHistoryUpsertWithWhereUniqueWithoutUserInput[]
    | BoughHistoryUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    BoughHistoryScalarWhereInput[] | BoughHistoryScalarWhereInput
  >;
}

export interface BoughHistoryUpdateWithWhereUniqueWithoutUserInput {
  where: BoughHistoryWhereUniqueInput;
  data: BoughHistoryUpdateWithoutUserDataInput;
}

export interface BoughHistoryUpdateWithoutUserDataInput {
  service?: Maybe<ServiceUpdateOneInput>;
}

export interface BoughHistoryUpsertWithWhereUniqueWithoutUserInput {
  where: BoughHistoryWhereUniqueInput;
  update: BoughHistoryUpdateWithoutUserDataInput;
  create: BoughHistoryCreateWithoutUserInput;
}

export interface BoughHistoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<BoughHistoryScalarWhereInput[] | BoughHistoryScalarWhereInput>;
  OR?: Maybe<BoughHistoryScalarWhereInput[] | BoughHistoryScalarWhereInput>;
  NOT?: Maybe<BoughHistoryScalarWhereInput[] | BoughHistoryScalarWhereInput>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface TenderUpsertWithWhereUniqueWithoutServiceInput {
  where: TenderWhereUniqueInput;
  update: TenderUpdateWithoutServiceDataInput;
  create: TenderCreateWithoutServiceInput;
}

export interface TenderScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  comment?: Maybe<String>;
  comment_not?: Maybe<String>;
  comment_in?: Maybe<String[] | String>;
  comment_not_in?: Maybe<String[] | String>;
  comment_lt?: Maybe<String>;
  comment_lte?: Maybe<String>;
  comment_gt?: Maybe<String>;
  comment_gte?: Maybe<String>;
  comment_contains?: Maybe<String>;
  comment_not_contains?: Maybe<String>;
  comment_starts_with?: Maybe<String>;
  comment_not_starts_with?: Maybe<String>;
  comment_ends_with?: Maybe<String>;
  comment_not_ends_with?: Maybe<String>;
  accept?: Maybe<Boolean>;
  accept_not?: Maybe<Boolean>;
  AND?: Maybe<TenderScalarWhereInput[] | TenderScalarWhereInput>;
  OR?: Maybe<TenderScalarWhereInput[] | TenderScalarWhereInput>;
  NOT?: Maybe<TenderScalarWhereInput[] | TenderScalarWhereInput>;
}

export interface TenderUpdateManyWithWhereNestedInput {
  where: TenderScalarWhereInput;
  data: TenderUpdateManyDataInput;
}

export interface TenderUpdateManyDataInput {
  price?: Maybe<Int>;
  comment?: Maybe<String>;
  accept?: Maybe<Boolean>;
}

export interface UserUpdateOneWithoutServicesInput {
  create?: Maybe<UserCreateWithoutServicesInput>;
  update?: Maybe<UserUpdateWithoutServicesDataInput>;
  upsert?: Maybe<UserUpsertWithoutServicesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutServicesDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  soldHistory?: Maybe<SoldHistoryUpdateManyWithoutUserInput>;
  boughHistory?: Maybe<BoughHistoryUpdateManyWithoutUserInput>;
}

export interface UserUpsertWithoutServicesInput {
  update: UserUpdateWithoutServicesDataInput;
  create: UserCreateWithoutServicesInput;
}

export interface ServiceUpsertNestedInput {
  update: ServiceUpdateDataInput;
  create: ServiceCreateInput;
}

export interface UserUpdateOneWithoutBoughHistoryInput {
  create?: Maybe<UserCreateWithoutBoughHistoryInput>;
  update?: Maybe<UserUpdateWithoutBoughHistoryDataInput>;
  upsert?: Maybe<UserUpsertWithoutBoughHistoryInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutBoughHistoryDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  services?: Maybe<ServiceUpdateManyWithoutUserInput>;
  soldHistory?: Maybe<SoldHistoryUpdateManyWithoutUserInput>;
}

export interface UserUpsertWithoutBoughHistoryInput {
  update: UserUpdateWithoutBoughHistoryDataInput;
  create: UserCreateWithoutBoughHistoryInput;
}

export interface CategoryCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  services?: Maybe<ServiceCreateManyWithoutCategoryInput>;
}

export interface ServiceCreateManyWithoutCategoryInput {
  create?: Maybe<
    ServiceCreateWithoutCategoryInput[] | ServiceCreateWithoutCategoryInput
  >;
  connect?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
}

export interface ServiceCreateWithoutCategoryInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  address: String;
  price: Int;
  done?: Maybe<Boolean>;
  timeToDo: String;
  created: String;
  tenders?: Maybe<TenderCreateManyWithoutServiceInput>;
  user?: Maybe<UserCreateOneWithoutServicesInput>;
  comments?: Maybe<CommentCreateManyWithoutServiceInput>;
}

export interface CategoryUpdateInput {
  title?: Maybe<String>;
  services?: Maybe<ServiceUpdateManyWithoutCategoryInput>;
}

export interface ServiceUpdateManyWithoutCategoryInput {
  create?: Maybe<
    ServiceCreateWithoutCategoryInput[] | ServiceCreateWithoutCategoryInput
  >;
  delete?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  connect?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  set?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  disconnect?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  update?: Maybe<
    | ServiceUpdateWithWhereUniqueWithoutCategoryInput[]
    | ServiceUpdateWithWhereUniqueWithoutCategoryInput
  >;
  upsert?: Maybe<
    | ServiceUpsertWithWhereUniqueWithoutCategoryInput[]
    | ServiceUpsertWithWhereUniqueWithoutCategoryInput
  >;
  deleteMany?: Maybe<ServiceScalarWhereInput[] | ServiceScalarWhereInput>;
  updateMany?: Maybe<
    | ServiceUpdateManyWithWhereNestedInput[]
    | ServiceUpdateManyWithWhereNestedInput
  >;
}

export interface ServiceUpdateWithWhereUniqueWithoutCategoryInput {
  where: ServiceWhereUniqueInput;
  data: ServiceUpdateWithoutCategoryDataInput;
}

export interface ServiceUpdateWithoutCategoryDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  address?: Maybe<String>;
  price?: Maybe<Int>;
  done?: Maybe<Boolean>;
  timeToDo?: Maybe<String>;
  created?: Maybe<String>;
  tenders?: Maybe<TenderUpdateManyWithoutServiceInput>;
  user?: Maybe<UserUpdateOneWithoutServicesInput>;
  comments?: Maybe<CommentUpdateManyWithoutServiceInput>;
}

export interface ServiceUpsertWithWhereUniqueWithoutCategoryInput {
  where: ServiceWhereUniqueInput;
  update: ServiceUpdateWithoutCategoryDataInput;
  create: ServiceCreateWithoutCategoryInput;
}

export interface CategoryUpdateManyMutationInput {
  title?: Maybe<String>;
}

export interface CommentCreateInput {
  id?: Maybe<ID_Input>;
  message: String;
  user?: Maybe<UserCreateOneInput>;
  service?: Maybe<ServiceCreateOneWithoutCommentsInput>;
}

export interface ServiceCreateOneWithoutCommentsInput {
  create?: Maybe<ServiceCreateWithoutCommentsInput>;
  connect?: Maybe<ServiceWhereUniqueInput>;
}

export interface ServiceCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  address: String;
  price: Int;
  done?: Maybe<Boolean>;
  timeToDo: String;
  created: String;
  tenders?: Maybe<TenderCreateManyWithoutServiceInput>;
  user?: Maybe<UserCreateOneWithoutServicesInput>;
  category?: Maybe<CategoryCreateOneWithoutServicesInput>;
}

export interface CommentUpdateInput {
  message?: Maybe<String>;
  user?: Maybe<UserUpdateOneInput>;
  service?: Maybe<ServiceUpdateOneWithoutCommentsInput>;
}

export interface ServiceUpdateOneWithoutCommentsInput {
  create?: Maybe<ServiceCreateWithoutCommentsInput>;
  update?: Maybe<ServiceUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<ServiceUpsertWithoutCommentsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ServiceWhereUniqueInput>;
}

export interface ServiceUpdateWithoutCommentsDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  address?: Maybe<String>;
  price?: Maybe<Int>;
  done?: Maybe<Boolean>;
  timeToDo?: Maybe<String>;
  created?: Maybe<String>;
  tenders?: Maybe<TenderUpdateManyWithoutServiceInput>;
  user?: Maybe<UserUpdateOneWithoutServicesInput>;
  category?: Maybe<CategoryUpdateOneWithoutServicesInput>;
}

export interface ServiceUpsertWithoutCommentsInput {
  update: ServiceUpdateWithoutCommentsDataInput;
  create: ServiceCreateWithoutCommentsInput;
}

export interface CommentUpdateManyMutationInput {
  message?: Maybe<String>;
}

export interface ServiceUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  address?: Maybe<String>;
  price?: Maybe<Int>;
  done?: Maybe<Boolean>;
  timeToDo?: Maybe<String>;
  created?: Maybe<String>;
  tenders?: Maybe<TenderUpdateManyWithoutServiceInput>;
  user?: Maybe<UserUpdateOneWithoutServicesInput>;
  category?: Maybe<CategoryUpdateOneWithoutServicesInput>;
  comments?: Maybe<CommentUpdateManyWithoutServiceInput>;
}

export interface ServiceUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  address?: Maybe<String>;
  price?: Maybe<Int>;
  done?: Maybe<Boolean>;
  timeToDo?: Maybe<String>;
  created?: Maybe<String>;
}

export interface SoldHistoryCreateInput {
  id?: Maybe<ID_Input>;
  service?: Maybe<ServiceCreateOneInput>;
  user?: Maybe<UserCreateOneWithoutSoldHistoryInput>;
}

export interface UserCreateOneWithoutSoldHistoryInput {
  create?: Maybe<UserCreateWithoutSoldHistoryInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutSoldHistoryInput {
  id?: Maybe<ID_Input>;
  name: String;
  email?: Maybe<String>;
  phone: String;
  services?: Maybe<ServiceCreateManyWithoutUserInput>;
  boughHistory?: Maybe<BoughHistoryCreateManyWithoutUserInput>;
}

export interface SoldHistoryUpdateInput {
  service?: Maybe<ServiceUpdateOneInput>;
  user?: Maybe<UserUpdateOneWithoutSoldHistoryInput>;
}

export interface UserUpdateOneWithoutSoldHistoryInput {
  create?: Maybe<UserCreateWithoutSoldHistoryInput>;
  update?: Maybe<UserUpdateWithoutSoldHistoryDataInput>;
  upsert?: Maybe<UserUpsertWithoutSoldHistoryInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutSoldHistoryDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  services?: Maybe<ServiceUpdateManyWithoutUserInput>;
  boughHistory?: Maybe<BoughHistoryUpdateManyWithoutUserInput>;
}

export interface UserUpsertWithoutSoldHistoryInput {
  update: UserUpdateWithoutSoldHistoryDataInput;
  create: UserCreateWithoutSoldHistoryInput;
}

export interface TenderCreateInput {
  id?: Maybe<ID_Input>;
  service?: Maybe<ServiceCreateOneWithoutTendersInput>;
  price: Int;
  user?: Maybe<UserCreateOneInput>;
  comment: String;
  accept?: Maybe<Boolean>;
}

export interface ServiceCreateOneWithoutTendersInput {
  create?: Maybe<ServiceCreateWithoutTendersInput>;
  connect?: Maybe<ServiceWhereUniqueInput>;
}

export interface ServiceCreateWithoutTendersInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  address: String;
  price: Int;
  done?: Maybe<Boolean>;
  timeToDo: String;
  created: String;
  user?: Maybe<UserCreateOneWithoutServicesInput>;
  category?: Maybe<CategoryCreateOneWithoutServicesInput>;
  comments?: Maybe<CommentCreateManyWithoutServiceInput>;
}

export interface TenderUpdateInput {
  service?: Maybe<ServiceUpdateOneWithoutTendersInput>;
  price?: Maybe<Int>;
  user?: Maybe<UserUpdateOneInput>;
  comment?: Maybe<String>;
  accept?: Maybe<Boolean>;
}

export interface ServiceUpdateOneWithoutTendersInput {
  create?: Maybe<ServiceCreateWithoutTendersInput>;
  update?: Maybe<ServiceUpdateWithoutTendersDataInput>;
  upsert?: Maybe<ServiceUpsertWithoutTendersInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ServiceWhereUniqueInput>;
}

export interface ServiceUpdateWithoutTendersDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  address?: Maybe<String>;
  price?: Maybe<Int>;
  done?: Maybe<Boolean>;
  timeToDo?: Maybe<String>;
  created?: Maybe<String>;
  user?: Maybe<UserUpdateOneWithoutServicesInput>;
  category?: Maybe<CategoryUpdateOneWithoutServicesInput>;
  comments?: Maybe<CommentUpdateManyWithoutServiceInput>;
}

export interface ServiceUpsertWithoutTendersInput {
  update: ServiceUpdateWithoutTendersDataInput;
  create: ServiceCreateWithoutTendersInput;
}

export interface TenderUpdateManyMutationInput {
  price?: Maybe<Int>;
  comment?: Maybe<String>;
  accept?: Maybe<Boolean>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  services?: Maybe<ServiceUpdateManyWithoutUserInput>;
  soldHistory?: Maybe<SoldHistoryUpdateManyWithoutUserInput>;
  boughHistory?: Maybe<BoughHistoryUpdateManyWithoutUserInput>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
}

export interface BoughHistorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BoughHistoryWhereInput>;
  AND?: Maybe<
    BoughHistorySubscriptionWhereInput[] | BoughHistorySubscriptionWhereInput
  >;
  OR?: Maybe<
    BoughHistorySubscriptionWhereInput[] | BoughHistorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    BoughHistorySubscriptionWhereInput[] | BoughHistorySubscriptionWhereInput
  >;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CategoryWhereInput>;
  AND?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
  OR?: Maybe<CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput>;
  NOT?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentWhereInput>;
  AND?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  OR?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  NOT?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
}

export interface ServiceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ServiceWhereInput>;
  AND?: Maybe<ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput>;
  OR?: Maybe<ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput>;
  NOT?: Maybe<ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput>;
}

export interface SoldHistorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SoldHistoryWhereInput>;
  AND?: Maybe<
    SoldHistorySubscriptionWhereInput[] | SoldHistorySubscriptionWhereInput
  >;
  OR?: Maybe<
    SoldHistorySubscriptionWhereInput[] | SoldHistorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    SoldHistorySubscriptionWhereInput[] | SoldHistorySubscriptionWhereInput
  >;
}

export interface TenderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TenderWhereInput>;
  AND?: Maybe<TenderSubscriptionWhereInput[] | TenderSubscriptionWhereInput>;
  OR?: Maybe<TenderSubscriptionWhereInput[] | TenderSubscriptionWhereInput>;
  NOT?: Maybe<TenderSubscriptionWhereInput[] | TenderSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface BoughHistory {
  id: ID_Output;
}

export interface BoughHistoryPromise
  extends Promise<BoughHistory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  service: <T = ServicePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface BoughHistorySubscription
  extends Promise<AsyncIterator<BoughHistory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  service: <T = ServiceSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface BoughHistoryNullablePromise
  extends Promise<BoughHistory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  service: <T = ServicePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface Service {
  id: ID_Output;
  title: String;
  description: String;
  address: String;
  price: Int;
  done: Boolean;
  timeToDo: String;
  created: String;
}

export interface ServicePromise extends Promise<Service>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  address: () => Promise<String>;
  price: () => Promise<Int>;
  done: () => Promise<Boolean>;
  timeToDo: () => Promise<String>;
  created: () => Promise<String>;
  tenders: <T = FragmentableArray<Tender>>(args?: {
    where?: TenderWhereInput;
    orderBy?: TenderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  user: <T = UserPromise>() => T;
  category: <T = CategoryPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ServiceSubscription
  extends Promise<AsyncIterator<Service>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Int>>;
  done: () => Promise<AsyncIterator<Boolean>>;
  timeToDo: () => Promise<AsyncIterator<String>>;
  created: () => Promise<AsyncIterator<String>>;
  tenders: <T = Promise<AsyncIterator<TenderSubscription>>>(args?: {
    where?: TenderWhereInput;
    orderBy?: TenderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  user: <T = UserSubscription>() => T;
  category: <T = CategorySubscription>() => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ServiceNullablePromise
  extends Promise<Service | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  address: () => Promise<String>;
  price: () => Promise<Int>;
  done: () => Promise<Boolean>;
  timeToDo: () => Promise<String>;
  created: () => Promise<String>;
  tenders: <T = FragmentableArray<Tender>>(args?: {
    where?: TenderWhereInput;
    orderBy?: TenderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  user: <T = UserPromise>() => T;
  category: <T = CategoryPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Tender {
  id: ID_Output;
  price: Int;
  comment: String;
  accept: Boolean;
}

export interface TenderPromise extends Promise<Tender>, Fragmentable {
  id: () => Promise<ID_Output>;
  service: <T = ServicePromise>() => T;
  price: () => Promise<Int>;
  user: <T = UserPromise>() => T;
  comment: () => Promise<String>;
  accept: () => Promise<Boolean>;
}

export interface TenderSubscription
  extends Promise<AsyncIterator<Tender>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  service: <T = ServiceSubscription>() => T;
  price: () => Promise<AsyncIterator<Int>>;
  user: <T = UserSubscription>() => T;
  comment: () => Promise<AsyncIterator<String>>;
  accept: () => Promise<AsyncIterator<Boolean>>;
}

export interface TenderNullablePromise
  extends Promise<Tender | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  service: <T = ServicePromise>() => T;
  price: () => Promise<Int>;
  user: <T = UserPromise>() => T;
  comment: () => Promise<String>;
  accept: () => Promise<Boolean>;
}

export interface User {
  id: ID_Output;
  name: String;
  email?: String;
  phone: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  services: <T = FragmentableArray<Service>>(args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  soldHistory: <T = FragmentableArray<SoldHistory>>(args?: {
    where?: SoldHistoryWhereInput;
    orderBy?: SoldHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  boughHistory: <T = FragmentableArray<BoughHistory>>(args?: {
    where?: BoughHistoryWhereInput;
    orderBy?: BoughHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  services: <T = Promise<AsyncIterator<ServiceSubscription>>>(args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  soldHistory: <T = Promise<AsyncIterator<SoldHistorySubscription>>>(args?: {
    where?: SoldHistoryWhereInput;
    orderBy?: SoldHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  boughHistory: <T = Promise<AsyncIterator<BoughHistorySubscription>>>(args?: {
    where?: BoughHistoryWhereInput;
    orderBy?: BoughHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  services: <T = FragmentableArray<Service>>(args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  soldHistory: <T = FragmentableArray<SoldHistory>>(args?: {
    where?: SoldHistoryWhereInput;
    orderBy?: SoldHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  boughHistory: <T = FragmentableArray<BoughHistory>>(args?: {
    where?: BoughHistoryWhereInput;
    orderBy?: BoughHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SoldHistory {
  id: ID_Output;
}

export interface SoldHistoryPromise extends Promise<SoldHistory>, Fragmentable {
  id: () => Promise<ID_Output>;
  service: <T = ServicePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface SoldHistorySubscription
  extends Promise<AsyncIterator<SoldHistory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  service: <T = ServiceSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface SoldHistoryNullablePromise
  extends Promise<SoldHistory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  service: <T = ServicePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface Category {
  id: ID_Output;
  title: String;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  services: <T = FragmentableArray<Service>>(args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  services: <T = Promise<AsyncIterator<ServiceSubscription>>>(args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CategoryNullablePromise
  extends Promise<Category | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  services: <T = FragmentableArray<Service>>(args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Comment {
  id: ID_Output;
  message: String;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
  user: <T = UserPromise>() => T;
  service: <T = ServicePromise>() => T;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  message: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  service: <T = ServiceSubscription>() => T;
}

export interface CommentNullablePromise
  extends Promise<Comment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
  user: <T = UserPromise>() => T;
  service: <T = ServicePromise>() => T;
}

export interface BoughHistoryConnection {
  pageInfo: PageInfo;
  edges: BoughHistoryEdge[];
}

export interface BoughHistoryConnectionPromise
  extends Promise<BoughHistoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BoughHistoryEdge>>() => T;
  aggregate: <T = AggregateBoughHistoryPromise>() => T;
}

export interface BoughHistoryConnectionSubscription
  extends Promise<AsyncIterator<BoughHistoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BoughHistoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBoughHistorySubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BoughHistoryEdge {
  node: BoughHistory;
  cursor: String;
}

export interface BoughHistoryEdgePromise
  extends Promise<BoughHistoryEdge>,
    Fragmentable {
  node: <T = BoughHistoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BoughHistoryEdgeSubscription
  extends Promise<AsyncIterator<BoughHistoryEdge>>,
    Fragmentable {
  node: <T = BoughHistorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBoughHistory {
  count: Int;
}

export interface AggregateBoughHistoryPromise
  extends Promise<AggregateBoughHistory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBoughHistorySubscription
  extends Promise<AsyncIterator<AggregateBoughHistory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ServiceConnection {
  pageInfo: PageInfo;
  edges: ServiceEdge[];
}

export interface ServiceConnectionPromise
  extends Promise<ServiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ServiceEdge>>() => T;
  aggregate: <T = AggregateServicePromise>() => T;
}

export interface ServiceConnectionSubscription
  extends Promise<AsyncIterator<ServiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ServiceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateServiceSubscription>() => T;
}

export interface ServiceEdge {
  node: Service;
  cursor: String;
}

export interface ServiceEdgePromise extends Promise<ServiceEdge>, Fragmentable {
  node: <T = ServicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ServiceEdgeSubscription
  extends Promise<AsyncIterator<ServiceEdge>>,
    Fragmentable {
  node: <T = ServiceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateService {
  count: Int;
}

export interface AggregateServicePromise
  extends Promise<AggregateService>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateServiceSubscription
  extends Promise<AsyncIterator<AggregateService>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SoldHistoryConnection {
  pageInfo: PageInfo;
  edges: SoldHistoryEdge[];
}

export interface SoldHistoryConnectionPromise
  extends Promise<SoldHistoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SoldHistoryEdge>>() => T;
  aggregate: <T = AggregateSoldHistoryPromise>() => T;
}

export interface SoldHistoryConnectionSubscription
  extends Promise<AsyncIterator<SoldHistoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SoldHistoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSoldHistorySubscription>() => T;
}

export interface SoldHistoryEdge {
  node: SoldHistory;
  cursor: String;
}

export interface SoldHistoryEdgePromise
  extends Promise<SoldHistoryEdge>,
    Fragmentable {
  node: <T = SoldHistoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SoldHistoryEdgeSubscription
  extends Promise<AsyncIterator<SoldHistoryEdge>>,
    Fragmentable {
  node: <T = SoldHistorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSoldHistory {
  count: Int;
}

export interface AggregateSoldHistoryPromise
  extends Promise<AggregateSoldHistory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSoldHistorySubscription
  extends Promise<AsyncIterator<AggregateSoldHistory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TenderConnection {
  pageInfo: PageInfo;
  edges: TenderEdge[];
}

export interface TenderConnectionPromise
  extends Promise<TenderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TenderEdge>>() => T;
  aggregate: <T = AggregateTenderPromise>() => T;
}

export interface TenderConnectionSubscription
  extends Promise<AsyncIterator<TenderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TenderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTenderSubscription>() => T;
}

export interface TenderEdge {
  node: Tender;
  cursor: String;
}

export interface TenderEdgePromise extends Promise<TenderEdge>, Fragmentable {
  node: <T = TenderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TenderEdgeSubscription
  extends Promise<AsyncIterator<TenderEdge>>,
    Fragmentable {
  node: <T = TenderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTender {
  count: Int;
}

export interface AggregateTenderPromise
  extends Promise<AggregateTender>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTenderSubscription
  extends Promise<AsyncIterator<AggregateTender>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface BoughHistorySubscriptionPayload {
  mutation: MutationType;
  node: BoughHistory;
  updatedFields: String[];
  previousValues: BoughHistoryPreviousValues;
}

export interface BoughHistorySubscriptionPayloadPromise
  extends Promise<BoughHistorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BoughHistoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BoughHistoryPreviousValuesPromise>() => T;
}

export interface BoughHistorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BoughHistorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BoughHistorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BoughHistoryPreviousValuesSubscription>() => T;
}

export interface BoughHistoryPreviousValues {
  id: ID_Output;
}

export interface BoughHistoryPreviousValuesPromise
  extends Promise<BoughHistoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface BoughHistoryPreviousValuesSubscription
  extends Promise<AsyncIterator<BoughHistoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  title: String;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  message: String;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  message: () => Promise<AsyncIterator<String>>;
}

export interface ServiceSubscriptionPayload {
  mutation: MutationType;
  node: Service;
  updatedFields: String[];
  previousValues: ServicePreviousValues;
}

export interface ServiceSubscriptionPayloadPromise
  extends Promise<ServiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ServicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ServicePreviousValuesPromise>() => T;
}

export interface ServiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ServiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ServiceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ServicePreviousValuesSubscription>() => T;
}

export interface ServicePreviousValues {
  id: ID_Output;
  title: String;
  description: String;
  address: String;
  price: Int;
  done: Boolean;
  timeToDo: String;
  created: String;
}

export interface ServicePreviousValuesPromise
  extends Promise<ServicePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  address: () => Promise<String>;
  price: () => Promise<Int>;
  done: () => Promise<Boolean>;
  timeToDo: () => Promise<String>;
  created: () => Promise<String>;
}

export interface ServicePreviousValuesSubscription
  extends Promise<AsyncIterator<ServicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Int>>;
  done: () => Promise<AsyncIterator<Boolean>>;
  timeToDo: () => Promise<AsyncIterator<String>>;
  created: () => Promise<AsyncIterator<String>>;
}

export interface SoldHistorySubscriptionPayload {
  mutation: MutationType;
  node: SoldHistory;
  updatedFields: String[];
  previousValues: SoldHistoryPreviousValues;
}

export interface SoldHistorySubscriptionPayloadPromise
  extends Promise<SoldHistorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SoldHistoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SoldHistoryPreviousValuesPromise>() => T;
}

export interface SoldHistorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SoldHistorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SoldHistorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SoldHistoryPreviousValuesSubscription>() => T;
}

export interface SoldHistoryPreviousValues {
  id: ID_Output;
}

export interface SoldHistoryPreviousValuesPromise
  extends Promise<SoldHistoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface SoldHistoryPreviousValuesSubscription
  extends Promise<AsyncIterator<SoldHistoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface TenderSubscriptionPayload {
  mutation: MutationType;
  node: Tender;
  updatedFields: String[];
  previousValues: TenderPreviousValues;
}

export interface TenderSubscriptionPayloadPromise
  extends Promise<TenderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TenderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TenderPreviousValuesPromise>() => T;
}

export interface TenderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TenderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TenderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TenderPreviousValuesSubscription>() => T;
}

export interface TenderPreviousValues {
  id: ID_Output;
  price: Int;
  comment: String;
  accept: Boolean;
}

export interface TenderPreviousValuesPromise
  extends Promise<TenderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  price: () => Promise<Int>;
  comment: () => Promise<String>;
  accept: () => Promise<Boolean>;
}

export interface TenderPreviousValuesSubscription
  extends Promise<AsyncIterator<TenderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  price: () => Promise<AsyncIterator<Int>>;
  comment: () => Promise<AsyncIterator<String>>;
  accept: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email?: String;
  phone: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Service",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "SoldHistory",
    embedded: false
  },
  {
    name: "BoughHistory",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "Tender",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
